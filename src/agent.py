import asyncio
import json

import forta_agent
from forta_agent import get_json_rpc_url
from web3 import Web3

from src.findings import TimelockFindings
from src.utils import check_new_min_delay_is_zero, extract_argument, Roles, bytes32_to_str

with open("./src/timelock_abi.json", 'r') as abi_file:  # get abi from the file
    timelock_abi = json.load(abi_file)

web3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))
# "MinDelayChange(uint256,uint256)" in the json format
min_delay_change_abi = next((x for x in timelock_abi if x.get('name', "") == "MinDelayChange"), None)
# "CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)" in the json format
call_scheduled_abi = next((x for x in timelock_abi if x.get("name", "") == "CallScheduled"), None)
# "CallExecuted(bytes32,uint256,address,uint256,bytes)" in the json format
call_executed_abi = next((x for x in timelock_abi if x.get("name", "") == "CallExecuted"), None)
# "RoleGranted(bytes32,address,address)" in the json format
role_granted_abi = next((x for x in timelock_abi if x.get("name", "") == "RoleGranted"), None)
# "RoleRevoked(bytes32,address,address)" in the json format
role_revoked_abi = next((x for x in timelock_abi if x.get("name", "") == "RoleRevoked"), None)


async def detect_main_exploit(transaction_event: forta_agent.transaction_event.TransactionEvent) -> list:
    """
    this function detects TimelockController main vulnerability exploit
    :param transaction_event: forta_agent.transaction_event.TransactionEvent
    :return: findings: list
    """
    findings = []
    danger_proposals_id = []

    # get "MinDelayChange(uint256,uint256)" events from the log
    for event in transaction_event.filter_log(json.dumps(min_delay_change_abi)):
        if await check_new_min_delay_is_zero(event):
            findings.append(await TimelockFindings.zero_delay_finding(event.get('address'), transaction_event.from_,
                                                                      transaction_event.transaction.hash,
                                                                      await extract_argument(event, "oldDuration")))

    # get "CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)" and
    # "CallExecuted(bytes32,uint256,address,uint256,bytes)" events from the log
    for ep_event in transaction_event.filter_log(
            [json.dumps(call_scheduled_abi), json.dumps(call_executed_abi)]):
        proposal_id = await bytes32_to_str(await extract_argument(ep_event, "id"))  # get proposal id from the event

        match ep_event.get("event", ""):
            case "CallExecuted":
                danger_proposals_id.append(proposal_id)  # add proposal id to danger list if it was executed
            case "CallScheduled":
                # check if proposal id is in the danger list, which means it was executed already
                if proposal_id in danger_proposals_id:
                    # and now check if timelock delay was changed in this queue
                    if next((x for x in findings if x.alert_id == "TIMELOCK-ZERO-DELAY"), None):
                        # alert main exploit
                        findings.append(await TimelockFindings.main_exploit_finding(transaction_event.from_,
                                                                                    ep_event.get('address'),
                                                                                    transaction_event.hash,
                                                                                    proposal_id))
                    else:
                        # alert proposal lifecycle violation
                        findings.append(await TimelockFindings.proposal_lifecycle_violation_finding(
                            transaction_event.from_,
                            ep_event.get('address'),
                            transaction_event.hash,
                            proposal_id))

    return findings


async def detect_new_role_for_executor(transaction_event: forta_agent.transaction_event.TransactionEvent, w3) -> list:
    """
    this function detects `RoleGranted(bytes32,address,address)` event for the executor and creates alert when executor
    gets proposer or admin roles
    :param transaction_event: forta_agent.transaction_event.TransactionEvent
    :param w3: web3 object, it was added here to be able to insert web3 mock and test the function
    :return: findings: list
    """
    findings = []

    # get `RoleGranted(bytes32,address,address)` events from the log
    for event in transaction_event.filter_log(json.dumps(role_granted_abi)):
        role = await extract_argument(event, "role")  # get the role signature which was granted
        account = await extract_argument(event, "account")  # get the address that got the new role
        address = event.get('address')  # get the contract address
        if "0x" + str(role.hex()) == Roles.executor.value:  # skip if it is Executor role granted
            return findings
        contract = w3.eth.contract(address=Web3.toChecksumAddress(address), abi=timelock_abi)
        # check does the address has executor role
        if contract.functions.hasRole(role=Roles.executor.value, account=account).call(transaction_event.block_number):
            match "0x" + str(role.hex()):

                case Roles.proposer.value:  # alert if the executor got the proposer role
                    findings.append(await TimelockFindings.executor_got_proposer_role_finding(account,
                                                                                              transaction_event.from_,
                                                                                              event.get('address'),
                                                                                              transaction_event.hash))

                case Roles.admin.value:  # alert if the executor got the admin role
                    findings.append(await TimelockFindings.executor_got_admin_role_finding(account,
                                                                                           transaction_event.from_,
                                                                                           event.get('address'),
                                                                                           transaction_event.hash))
    return findings


async def detect_untrusted_executor(transaction_event: forta_agent.transaction_event.TransactionEvent, w3) -> list:
    """
    this function detects untrusted executors as it is described in
    https://forum.openzeppelin.com/t/timelockcontroller-vulnerability-post-mortem/14958
    :param transaction_event: forta_agent.transaction_event.TransactionEvent
    :param w3: web3 object, it was added here to be able to insert web3 mock and test the function
    :return: findings: list
    """
    findings = []
    block_number = transaction_event.block_number

    # filter timelockController events
    for event in transaction_event.filter_log([json.dumps(abi) for abi in timelock_abi]):
        account = transaction_event.from_  # get the address, that triggered these events
        address = event.get('address')  # get the contact address
        contract = w3.eth.contract(address=Web3.toChecksumAddress(address), abi=timelock_abi)
        # check does this address have executor role
        has_exec = contract.functions.hasRole(role=Roles.executor.value, account=account).call(block_number)
        if not has_exec:
            return findings  # return empty list if not
        # check does this address have proposer role
        has_prop = contract.functions.hasRole(role=Roles.proposer.value, account=account).call(block_number)
        if has_exec and not has_prop:  # alert if executor hasn't proposer role
            findings.append(await TimelockFindings.untrusted_executor_finding(event.get('address'),
                                                                              transaction_event.from_))
            return findings
    return findings


async def detect_revoke_role(transaction_event: forta_agent.transaction_event.TransactionEvent) -> list:
    """
    This function detects RevokeRole events
    :param transaction_event: forta_agent.transaction_event.TransactionEvent
    :param w3: web3 object, it was added here to be able to insert web3 mock and test the function
    :return: findings: list
    """
    findings = []

    # get `RoleRevoked(bytes32,address,address)` events from the log
    for event in transaction_event.filter_log(json.dumps(role_revoked_abi)):
        account = await extract_argument(event, "account")  # extract account
        role = await extract_argument(event, "role")  # extract role
        role = "0x" + str(role.hex())

        if transaction_event.transaction.to == account and role == Roles.admin.value:
            # alert if contract lost its Admin role
            findings.append(
                await TimelockFindings.contract_lost_selfadministration_finding(transaction_event.from_, account,
                                                                                transaction_event.hash))
        elif transaction_event.from_ == account:
            # alert if user removes his own role
            findings.append(
                await TimelockFindings.role_renounced_finding(transaction_event.from_, transaction_event.hash, role,
                                                              transaction_event.to))
        else:
            # create info-alert if there is normal RoleRevoked event in the log
            findings.append(
                await TimelockFindings.role_revoked_finding(transaction_event.from_, account, transaction_event.hash,
                                                            role,
                                                            transaction_event.to))

    return findings


async def main(transaction_event: forta_agent.transaction_event.TransactionEvent, w3):
    """
    This function is used to start detect-functions in the different threads and then gather the findings
    """
    return await asyncio.gather(
        detect_untrusted_executor(transaction_event, w3),
        detect_new_role_for_executor(transaction_event, w3),
        detect_main_exploit(transaction_event),
        detect_revoke_role(transaction_event)
    )


def provide_handle_transaction(w3):
    def handle_transaction(transaction_event: forta_agent.transaction_event.TransactionEvent) -> list:
        return [finding for findings in asyncio.run(main(transaction_event, w3)) for finding in findings]

    return handle_transaction


real_handle_transaction = provide_handle_transaction(web3)


def handle_transaction(transaction_event: forta_agent.transaction_event.TransactionEvent):
    return real_handle_transaction(transaction_event)
