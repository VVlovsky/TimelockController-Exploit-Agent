import eth_abi
from eth_utils import encode_hex, keccak
from forta_agent import create_transaction_event, FindingSeverity, FindingType

from src.agent import provide_handle_transaction, Roles
from src.test.web3_mock import Web3Mock

min_delay_change = "MinDelayChange(uint256,uint256)"
call_schedule = "CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)"
cancelled = "Cancelled(bytes32)"
call_executed = "CallExecuted(bytes32,uint256,address,uint256,bytes)"
role_granted = 'RoleGranted(bytes32,address,address)'
role_revoked = "RoleRevoked(bytes32,address,address)"
EXPLOIT_TARGET_ADDRESS = "0x0000000000000000000000000000000000000000"
malicious_executor_address = "0x1111111111111111111111111111111111111111"
RANDOM_ADDRESS = "0x3333333333333333333333333333333333333333"
w3 = Web3Mock({malicious_executor_address: Roles.executor.value})

# --------------------- MinDelayChange(uint256,uint256) MOCK --------------------- #
hash = keccak(text=min_delay_change)
data = eth_abi.encode_abi(["uint256", "uint256"], [20, 0])
data = encode_hex(data)
topics = [hash]
log_min_delay_change = {'topics': topics,
                        'data': data,
                        'address': EXPLOIT_TARGET_ADDRESS}

# --- CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256) MOCK --- #
hash = keccak(text=call_schedule)
data = eth_abi.encode_abi(["address", "uint256", "bytes", "bytes32", "uint256"],
                          [EXPLOIT_TARGET_ADDRESS, 0, bytes(0), bytes(0), 0])
data = encode_hex(data)
id = eth_abi.encode_abi(["bytes32"], [bytes("EXPLOIT_ID", 'utf-8')])
id = encode_hex(id)
index = eth_abi.encode_abi(["uint256"], [0])
index = encode_hex(index)
topics = [hash, id, index]
log_call_schedule = {'topics': topics,
                     'data': data,
                     'address': EXPLOIT_TARGET_ADDRESS}

# ------------ CallExecuted(bytes32,uint256,address,uint256,bytes) MOCK ------------ #
hash = keccak(text=call_executed)
data = eth_abi.encode_abi(["address", "uint256", "bytes"],
                          [EXPLOIT_TARGET_ADDRESS, 0, bytes(0)])
data = encode_hex(data)
id = eth_abi.encode_abi(["bytes32"], [bytes("EXPLOIT_ID", 'utf-8')])
id = encode_hex(id)
index = eth_abi.encode_abi(["uint256"], [0])
index = encode_hex(index)
topics = [hash, id, index]
log_call_executed = {'topics': topics,
                     'data': data,
                     'address': EXPLOIT_TARGET_ADDRESS}

# -------------------- RoleGranted(bytes32,address,address) MOCK -------------------- #
hash = keccak(text=role_granted)
data = eth_abi.encode_abi([], [])
data = encode_hex(data)
proposer = eth_abi.encode_abi(["bytes32"], [bytes.fromhex(Roles.proposer.value[2:])])
proposer = encode_hex(proposer)
admin = eth_abi.encode_abi(["bytes32"], [bytes.fromhex(Roles.admin.value[2:])])
admin = encode_hex(admin)
account = eth_abi.encode_abi(["address"], [malicious_executor_address])
account = encode_hex(account)
sender = eth_abi.encode_abi(["address"], [malicious_executor_address])
sender = encode_hex(sender)
topics = [hash, proposer, account, sender]
log_role_granted_proposer = {'topics': topics,
                             'data': data,
                             'address': EXPLOIT_TARGET_ADDRESS}
topics = [hash, admin, account, sender]
log_role_granted_admin = {'topics': topics,
                          'data': data,
                          'address': EXPLOIT_TARGET_ADDRESS}

# -------------------- RoleRevoked(bytes32,address,address) MOCK -------------------- #
hash = keccak(text=role_revoked)
data = eth_abi.encode_abi([], [])
data = encode_hex(data)
admin = eth_abi.encode_abi(["bytes32"], [bytes.fromhex(Roles.admin.value[2:])])
admin = encode_hex(admin)
account = eth_abi.encode_abi(["address"], [RANDOM_ADDRESS])
account = encode_hex(account)
contract = eth_abi.encode_abi(["address"], [EXPLOIT_TARGET_ADDRESS])
contract = encode_hex(contract)
sender = eth_abi.encode_abi(["address"], [malicious_executor_address])
sender = encode_hex(sender)
topics = [hash, admin, contract, sender]
log_role_revoked_contract = {'topics': topics,
                             'data': data,
                             'address': EXPLOIT_TARGET_ADDRESS}
topics = [hash, admin, sender, sender]
log_role_renounced = {'topics': topics,
                      'data': data,
                      'address': EXPLOIT_TARGET_ADDRESS}
topics = [hash, admin, account, sender]
log_role_revoked = {'topics': topics,
                    'data': data,
                    'address': EXPLOIT_TARGET_ADDRESS}


class TestTimelockControllerAgent:
    def test_returns_main_exploit_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_granted_proposer, log_min_delay_change, log_call_executed, log_call_schedule]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.name == "TimelockController Exploit Alert"), None)

        assert finding.alert_id == 'TIMELOCK-EXPLOIT'
        assert finding.description == f'{malicious_executor_address} exploit TimelockController {EXPLOIT_TARGET_ADDRESS}'
        assert finding.severity == FindingSeverity.Critical
        assert finding.type == FindingType.Exploit
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('executor') == malicious_executor_address
        assert finding.metadata.get('proposal_id') == "EXPLOIT_ID"

    def test_dont_return_main_finding_if_executed_after_schedule(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_granted_proposer, log_min_delay_change, log_call_schedule, log_call_executed]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.name == "TimelockController Exploit Alert"), None)

        assert not finding

    def test_return_only_proposal_lifecycle_violation_finding_if_min_delay_was_not_changed(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_granted_proposer, log_call_executed, log_call_schedule]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.name == "TimelockController Exploit Alert"), None)
        assert not finding
        finding = next((x for x in findings if x.alert_id == "TIMELOCK-PROPOSAL-LIFECYCLE-VIOLATION"), None)
        assert finding.alert_id == 'TIMELOCK-PROPOSAL-LIFECYCLE-VIOLATION'
        assert finding.description == f'Proposal EXPLOIT_ID for contact {EXPLOIT_TARGET_ADDRESS} was executed before scheduled'
        assert finding.severity == FindingSeverity.Critical
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('executor') == malicious_executor_address
        assert finding.metadata.get('proposal_id') == "EXPLOIT_ID"

    def test_return_zero_delay_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_min_delay_change]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-ZERO-DELAY'), None)
        assert finding
        assert finding.description == f'{malicious_executor_address} set TimelockController Minimum Delay to zero'
        assert finding.severity == FindingSeverity.Info
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('old_delay') == 20

    def test_return_executor_got_proposer_role_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_granted_proposer]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-EXECUTOR-PROPOSER'), None)
        assert finding
        assert finding.description == f'TimelockController {EXPLOIT_TARGET_ADDRESS} executor {malicious_executor_address} got proposer role'
        assert finding.severity == FindingSeverity.Medium
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('executor') == malicious_executor_address
        assert finding.metadata.get('initiator') == malicious_executor_address

    def test_return_executor_got_admin_role_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_granted_admin]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-EXECUTOR-ADMIN'), None)
        assert finding
        assert finding.description == f'TimelockController {EXPLOIT_TARGET_ADDRESS} executor {malicious_executor_address} got admin role'
        assert finding.severity == FindingSeverity.Critical
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('executor') == malicious_executor_address
        assert finding.metadata.get('initiator') == malicious_executor_address

    def test_returns_untrusted_executor_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_call_executed]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = findings[0]
        assert finding
        assert finding.description == f'TimelockController executor {malicious_executor_address} is untrusted!'
        assert finding.severity == FindingSeverity.High
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('executor') == malicious_executor_address

    def test_return_contact_lost_selfadministration_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0",
                'to': EXPLOIT_TARGET_ADDRESS
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_revoked_contract]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-ADMIN-REVOKED'), None)
        assert finding
        assert finding.description == f'Contract`s {EXPLOIT_TARGET_ADDRESS} role "ADMIN" was revoked'
        assert finding.severity == FindingSeverity.High
        assert finding.type == FindingType.Suspicious
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('from') == malicious_executor_address

    def test_return_renounced_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0",
                'to': EXPLOIT_TARGET_ADDRESS
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_renounced]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-ROLE-RENOUNCED'), None)
        assert finding
        assert finding.description == f'Address {malicious_executor_address} renounced its own role {Roles.admin.value}'
        assert finding.severity == FindingSeverity.Medium
        assert finding.type == FindingType.Info
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('from') == malicious_executor_address
        assert finding.metadata.get('role') == Roles.admin.value

    def test_return_role_revoked_finding(self):
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0",
                'to': EXPLOIT_TARGET_ADDRESS
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_role_revoked]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        finding = next((x for x in findings if x.alert_id == 'TIMELOCK-ROLE-REVOKED'), None)
        assert finding
        assert finding.description == f'Address {malicious_executor_address} revoked role {Roles.admin.value} of the address {RANDOM_ADDRESS}'
        assert finding.severity == FindingSeverity.Medium
        assert finding.type == FindingType.Info
        assert finding.metadata.get('contract') == EXPLOIT_TARGET_ADDRESS
        assert finding.metadata.get('tx_hash') == "0"
        assert finding.metadata.get('from') == malicious_executor_address
        assert finding.metadata.get('role') == Roles.admin.value
        assert finding.metadata.get('account') == RANDOM_ADDRESS

    def test_returns_zero_findings_if_executor_has_proposer_role_and_everything_is_ok(self):
        w3 = Web3Mock({malicious_executor_address: [Roles.executor.value, Roles.proposer.value]})
        tx_event = create_transaction_event({
            'transaction': {
                'from': malicious_executor_address,
                'hash': "0"
            },
            'block': {
                'number': 0
            },
            'receipt': {
                'logs': [log_call_executed]}
        })

        findings = provide_handle_transaction(w3)(tx_event)
        assert not findings
